\documentclass[notes]{beamer}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\usepackage[backend=bibtex]{biblatex}
\bibliography{presentation}

%% \usepackage{listings}
%% \lstdefinelanguage{GraphQL}{
%%   keywords={type,enum,union,interface},
%%   morekeywords={ID,String,Integer}
%%   sensitive=true,
%%   comment=[l]{#},
%%   morestring=[b]"
%% }

\title{GraphQL:\@Thinking in Resolvers}
\author{Sébastien Lavoie-Courchesne}
\date{February 23rd 2022}

\begin{document}
\begin{frame}
  \titlepage{}
\end{frame}

\section{Introduction}
\begin{frame}
  opening
\end{frame}


\begin{frame}
  \frametitle{Sébastien Lavoie-Courchesne}
  \begin{itemize}
  \item Architect for the Catalog Group at AppDirect
  \item Member of the GraphQL Working Group at AppDirect
  \item Developed most of the initial infrastructure we use
  \end{itemize}
\end{frame}


\begin{frame}
  \frametitle{Contents}
\end{frame}


\begin{frame}
  \frametitle{Technologies used in the examples}
  \begin{itemize}
  \item GraphQL schemas
  \item ApolloServer stack:
    \begin{itemize}
    \item NodeJS
    \item Typescript
    \item ApolloServer
    \end{itemize}
  \end{itemize}
\end{frame}


\section{GraphQL}
\begin{frame}
  \frametitle{What is GraphQL?}
  From the GraphQL Specification\cite{graphql-spec}:
  \begin{quote}
    GraphQL is a query language designed to build client applications by providing an intuitive and flexible syntax and system for describing their data requirements and interactions.
  \end{quote}
\end{frame}


\begin{frame}
  \frametitle{But What is GraphQL?}
  A specification defining a query language for communication between different services over a network and how to implement the server and client sides of the communication
\end{frame}


\begin{frame}
  \frametitle{Why GraphQL?}
  Only request and receive the fields you want:
  \begin{itemize}
  \item Smaller payloads
  \item Descriptive language
  \item Documented
  \end{itemize}
\end{frame}
\note{
  Often compared to REST and gRPC
  
  Mostly used over HTTP, but not always
}


\begin{frame}
  \frametitle{How does it work?}
  Server defines the schema it serves using the GraphQL language

  Clients can read the schema and send queries to the server using the GraphQL language, optionally passing in variables
\end{frame}
\note{typically one query per request, multiple queries in a single request are supported}


\begin{frame}
  \frametitle{Operations}
  \begin{description}
    \item[Query] a read-only fetch, analogous to REST GET
    \item[Mutation] a write followed by a fetch, analogous to REST POST/PATCH/PUT/DELETE
    \item[Subscription] a long-lived request that fetches data in response to source events
  \end{description}
\end{frame}
\note{Subscription is less often used and less documented, multiple ways to serve it (WebSocket, Kafka, RabbitMQ, etc)}


\begin{frame}
  \frametitle{HTTP Communication}
  \begin{itemize}
  \item Most common use of GraphQL
  \item HTTP GET or POST to a specific URL
  \item Traditional HTTP headers/cookies
  \item GET \texttt{query} parameter contains the query as a string
  \item POST Body includes
    \begin{itemize}
    \item[\texttt{query}] Query as a string
    \item[\texttt{variables}] Query variable values as a JSON object, optional
    \item[\texttt{operationName}] Name for the operation, optional
    \end{itemize}
  \end{itemize}
\end{frame}


\section{GraphQL Language}
\begin{frame}[fragile]
  \frametitle{Primitives}
  \texttt{scalar} represent a single value. Predefined: ID, String, Int, Float, Boolean.
  \begin{verbatim}
    \"Date and Time represented using the ISO 8601 standard\"
    scalar DateTime

    "Email represented as a String, format validated when used as input"
    scalar Email
  \end{verbatim}

  \texttt{enum} represent an enumeration of possible values. Serialized as strings.
  \begin{verbatim}
    "Cardinal directions"
    enum Direction {
      NORTH
      EAST
      SOUTH
      WEST
    }
  \end{verbatim}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Modifiers}
  \texttt{!} to denote a non-nullable field
  \begin{verbatim}
    "Non-nullable identifier"
    ID!
  \end{verbatim}

  \texttt{[]} to denote a list of elements, around the type
  \begin{verbatim}
    "Nullable list of nullable strings"
    [String]

    "Non-nullable list of nullable strings"
    [String]!

    "Nullable list of non-nullable strings"
    [String!]

    "Non-nullable list of non-nullable strings"
    [String!]!
  \end{verbatim}
\end{frame}
\note{
  nullability can be used to indicate a missing value, returning null for a non-nullable type generates an error

  an empty list is non-null

  good practice to have non-nullable elements within the list
}


\begin{frame}[fragile]
  \frametitle{Objects}
  \texttt{type} used to represent a list of named and typed output fields
  \begin{verbatim}
    "A blog post"
    type Blog {
      "Identified of the blog post"
      id: ID!

      "Title of the blog post"
      title: String!

      "Comments on the blog post"
      comments: [Comment!]!

      "Formatted content"
      content(format: ContentFormat = HTML): String!
    }
  \end{verbatim}

  \texttt{input} used to represent a list of named and typed input fields, can only contain primitives and other input types
  \begin{verbatim}
    "Input used to create a new blog"
    input CreateBlogInput {
      "Title of the new blog"
      title: String!

      "Contents"
      contents: String!
    }
  \end{verbatim}
\end{frame}
\note{
  arguments can be added to fields to allow specifying more information about what should be returned, format, locale, page for collections, etc

  only input objects and primitives can be used as arguments, input fields cannot have arguments
}


\begin{frame}[fragile]
  \frametitle{Abstractions}
  \texttt{interface} used to represent a list of named and typed output fields, implemented by types
  \begin{verbatim}
    "A identified and queryable node within the graph"
    interface Node {
      "Identifier of the node"
      id: ID!
    }

    "A blog post"
    type Blog implements Node {
      "Identifier of the blog"
      id: ID!

      "Title of the blog"
      title: String!
    }
  \end{verbatim}

  \texttt{union} to represent a collection of possible output types
  \begin{verbatim}
    "A comment on a blog post"
    type BlogComment {
      "Identifier"
      id: ID!

      "Comment text"
      text: String!

      "Blog on which the comment was made"
      blog: Blog!
    }

    "A comment on a comment"
    type CommentComment {
      "Identifier"
      id: ID!

      "Comment text"
      text: String!

      "Comment on which the comment was made"
      comment: Comment!
    }

    "Possible comments"
    union Comment = BlogComment | CommentComment
  \end{verbatim}
\end{frame}
\note{
  any number of types can implement the interface

  unions can be combined with interfaces to create more powerful abstractions, done by adding the same interface to every type in the union
}


\begin{frame}[fragile]
  \frametitle{Directives}
  Annotations on the graph, prefixed with \@, can have arguments. Predefined:
  \begin{description}
  \item[\texttt{@deprecated(reason: String!)}] indicate to the client the element is deprecated, along with a reason
  \item[\texttt{@skip(if: Boolean!)}] don't return the field's value when the condition is false
  \item[\texttt{@include(if: Boolean!)}] return the field's value only when the condition is true
  \item[\texttt{@specifiedBy(url: String!)}] add formatting information for scalars, usually pointed to a standard or specification
  \end{description}

  \begin{verbatim}
    # defining a custom directive to validate authorization for queries, mutations and subscriptions
    directive @authorization(scopes: [String!]!) on QUERY | MUTATION | SUBSCRIPTION
    
    "A deprecated type"
    type Comment @deprecated(reason: "Replaced by BlogComment and CommentComment") { ... }

    "Date and Time represented using the ISO 8601 standard"
    scalar DateTime @specifiedBy(url: "https://www.iso.org/iso-8601-date-and-time-format.html")
  \end{verbatim}
\end{frame}


\section{Resolver}
\section{Federation}
\section{Conclusion}
\begin{frame}{Conclusion}
\end{frame}

\begin{frame}{Links}
  \begin{itemize}
  \item blog
  \item this presentation
  \end{itemize}
\end{frame}

\begin{frame}{References}
  \printbibliography{}
\end{frame}

\end{document}
